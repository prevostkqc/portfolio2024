(function (factory) { if (typeof define === 'function' && define.amd) { define(['jquery'], factory) } else if (typeof module === 'object' && module.exports) { module.exports = factory(require('jquery')) } else { factory(jQuery) } }(function ($) {
    var slice = Array.prototype.slice; var splice = Array.prototype.splice; var defaults = { topSpacing: 0, bottomSpacing: 0, className: 'is-sticky', wrapperClassName: 'sticky-wrapper', center: !1, getWidthFrom: '', widthFromWrapper: !0, responsiveWidth: !1, zIndex: 'inherit' }, $window = $(window), $document = $(document), sticked = [], windowHeight = $window.height(), scroller = function () {
        var scrollTop = $window.scrollTop(), documentHeight = $document.height(), dwh = documentHeight - windowHeight, extra = (scrollTop > dwh) ? dwh - scrollTop : 0; for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i], elementTop = s.stickyWrapper.offset().top, etse = elementTop - s.topSpacing - extra; s.stickyWrapper.css('height', s.stickyElement.outerHeight()); if (scrollTop <= etse) { if (s.currentTop !== null) { s.stickyElement.css({ 'width': '', 'position': '', 'top': '', 'z-index': '' }); s.stickyElement.parent().removeClass(s.className); s.stickyElement.trigger('sticky-end', [s]); s.currentTop = null } }
            else {
                var newTop = documentHeight - s.stickyElement.outerHeight() - s.topSpacing - s.bottomSpacing - scrollTop - extra; if (newTop < 0) { newTop = newTop + s.topSpacing } else { newTop = s.topSpacing }
                if (s.currentTop !== newTop) {
                    var newWidth; if (s.getWidthFrom) { padding = s.stickyElement.innerWidth() - s.stickyElement.width(); newWidth = $(s.getWidthFrom).width() - padding || null } else if (s.widthFromWrapper) { newWidth = s.stickyWrapper.width() }
                    if (newWidth == null) { newWidth = s.stickyElement.width() }
                    s.stickyElement.css('width', newWidth).css('position', 'fixed').css('top', newTop).css('z-index', s.zIndex); s.stickyElement.parent().addClass(s.className); if (s.currentTop === null) { s.stickyElement.trigger('sticky-start', [s]) } else { s.stickyElement.trigger('sticky-update', [s]) }
                    if (s.currentTop === s.topSpacing && s.currentTop > newTop || s.currentTop === null && newTop < s.topSpacing) { s.stickyElement.trigger('sticky-bottom-reached', [s]) } else if (s.currentTop !== null && newTop === s.topSpacing && s.currentTop < newTop) { s.stickyElement.trigger('sticky-bottom-unreached', [s]) }
                    s.currentTop = newTop
                }
                var stickyWrapperContainer = s.stickyWrapper.parent(); var unstick = (s.stickyElement.offset().top + s.stickyElement.outerHeight() >= stickyWrapperContainer.offset().top + stickyWrapperContainer.outerHeight()) && (s.stickyElement.offset().top <= s.topSpacing); if (unstick) { s.stickyElement.css('position', 'absolute').css('top', '').css('bottom', 0).css('z-index', '') } else { s.stickyElement.css('position', 'fixed').css('top', newTop).css('bottom', '').css('z-index', s.zIndex) }
            }
        }
    }, resizer = function () {
        windowHeight = $window.height(); for (var i = 0, l = sticked.length; i < l; i++) {
            var s = sticked[i]; var newWidth = null; if (s.getWidthFrom) { if (s.responsiveWidth) { newWidth = $(s.getWidthFrom).width() } } else if (s.widthFromWrapper) { newWidth = s.stickyWrapper.width() }
            if (newWidth != null) { s.stickyElement.css('width', newWidth) }
        }
    }, methods = {
        init: function (options) {
            return this.each(function () {
                var o = $.extend({}, defaults, options); var stickyElement = $(this); var stickyId = stickyElement.attr('id'); var wrapperId = stickyId ? stickyId + '-' + defaults.wrapperClassName : defaults.wrapperClassName; var wrapper = $('<div></div>').attr('id', wrapperId).addClass(o.wrapperClassName); stickyElement.wrapAll(function () { if ($(this).parent("#" + wrapperId).length == 0) { return wrapper } }); var stickyWrapper = stickyElement.parent(); if (o.center) { stickyWrapper.css({ width: stickyElement.outerWidth(), marginLeft: "auto", marginRight: "auto" }) }
                if (stickyElement.css("float") === "right") { stickyElement.css({ "float": "none" }).parent().css({ "float": "right" }) }
                o.stickyElement = stickyElement; o.stickyWrapper = stickyWrapper; o.currentTop = null; sticked.push(o); methods.setWrapperHeight(this); methods.setupChangeListeners(this)
            })
        }, setWrapperHeight: function (stickyElement) { var element = $(stickyElement); var stickyWrapper = element.parent(); if (stickyWrapper) { stickyWrapper.css('height', element.outerHeight()) } }, setupChangeListeners: function (stickyElement) { if (window.MutationObserver) { var mutationObserver = new window.MutationObserver(function (mutations) { if (mutations[0].addedNodes.length || mutations[0].removedNodes.length) { methods.setWrapperHeight(stickyElement) } }); mutationObserver.observe(stickyElement, { subtree: !0, childList: !0 }) } else { if (window.addEventListener) { stickyElement.addEventListener('DOMNodeInserted', function () { methods.setWrapperHeight(stickyElement) }, !1); stickyElement.addEventListener('DOMNodeRemoved', function () { methods.setWrapperHeight(stickyElement) }, !1) } else if (window.attachEvent) { stickyElement.attachEvent('onDOMNodeInserted', function () { methods.setWrapperHeight(stickyElement) }); stickyElement.attachEvent('onDOMNodeRemoved', function () { methods.setWrapperHeight(stickyElement) }) } } }, update: scroller, unstick: function (options) {
            return this.each(function () {
                var that = this; var unstickyElement = $(that); var removeIdx = -1; var i = sticked.length; while (i-- > 0) { if (sticked[i].stickyElement.get(0) === that) { splice.call(sticked, i, 1); removeIdx = i } }
                if (removeIdx !== -1) { unstickyElement.unwrap(); unstickyElement.css({ 'width': '', 'position': '', 'top': '', 'float': '', 'z-index': '' }) }
            })
        }
    }; if (window.addEventListener) { window.addEventListener('scroll', scroller, !1); window.addEventListener('resize', resizer, !1) } else if (window.attachEvent) { window.attachEvent('onscroll', scroller); window.attachEvent('onresize', resizer) }
    $.fn.sticky = function (method) { if (methods[method]) { return methods[method].apply(this, slice.call(arguments, 1)) } else if (typeof method === 'object' || !method) { return methods.init.apply(this, arguments) } else { $.error('Method ' + method + ' does not exist on jQuery.sticky') } }; $.fn.unstick = function (method) { if (methods[method]) { return methods[method].apply(this, slice.call(arguments, 1)) } else if (typeof method === 'object' || !method) { return methods.unstick.apply(this, arguments) } else { $.error('Method ' + method + ' does not exist on jQuery.sticky') } }; $(function () { setTimeout(scroller, 0) })
}))

try {

    (function (factory) {
        if (typeof define === 'function' && define.amd) {
            define([], factory)
        }
        else if (typeof exports === 'object') {
            module.exports = factory()
        } else {
            window.noUiSlider = factory()
        }
    }

    (function () {
        'use strict'; var VERSION = '10.0.0'; function isValidFormatter(entry) { return typeof entry === 'object' && typeof entry.to === 'function' && typeof entry.from === 'function' }
        function removeElement(el) { el.parentElement.removeChild(el) }
        function preventDefault(e) { e.preventDefault() }
        function unique(array) { return array.filter(function (a) { return !this[a] ? this[a] = !0 : !1 }, {}) }
        function closest(value, to) { return Math.round(value / to) * to }
        function offset(elem, orientation) {
            var rect = elem.getBoundingClientRect(); var doc = elem.ownerDocument; var docElem = doc.documentElement; var pageOffset = getPageOffset(doc); if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) { pageOffset.x = 0 }
            return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft)
        }
        function isNumeric(a) { return typeof a === 'number' && !isNaN(a) && isFinite(a) }
        function addClassFor(element, className, duration) { if (duration > 0) { addClass(element, className); setTimeout(function () { removeClass(element, className) }, duration) } }
        function limit(a) { return Math.max(Math.min(a, 100), 0) }
        function asArray(a) { return Array.isArray(a) ? a : [a] }
        function countDecimals(numStr) { numStr = String(numStr); var pieces = numStr.split("."); return pieces.length > 1 ? pieces[1].length : 0 }
        function addClass(el, className) { if (el.classList) { el.classList.add(className) } else { el.className += ' ' + className } }
        function removeClass(el, className) { if (el.classList) { el.classList.remove(className) } else { el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ') } }
        function hasClass(el, className) { return el.classList ? el.classList.contains(className) : new RegExp('\\b' + className + '\\b').test(el.className) }
        function getPageOffset(doc) { var supportPageOffset = window.pageXOffset !== undefined; var isCSS1Compat = ((doc.compatMode || "") === "CSS1Compat"); var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft; var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop; return { x: x, y: y } }
        function getActions() { return window.navigator.pointerEnabled ? { start: 'pointerdown', move: 'pointermove', end: 'pointerup' } : window.navigator.msPointerEnabled ? { start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp' } : { start: 'mousedown touchstart', move: 'mousemove touchmove', end: 'mouseup touchend' } }
        function getSupportsPassive() {
            var supportsPassive = !1; try { var opts = Object.defineProperty({}, 'passive', { get: function () { supportsPassive = !0 } }); window.addEventListener('test', null, opts) } catch (e) { }
            return supportsPassive
        }
        function getSupportsTouchActionNone() { return window.CSS && CSS.supports && CSS.supports('touch-action', 'none') }
        function subRangeRatio(pa, pb) { return (100 / (pb - pa)) }
        function fromPercentage(range, value) { return (value * 100) / (range[1] - range[0]) }
        function toPercentage(range, value) { return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]) }
        function isPercentage(range, value) { return ((value * (range[1] - range[0])) / 100) + range[0] }
        function getJ(value, arr) {
            var j = 1; while (value >= arr[j]) { j += 1 }
            return j
        }
        function toStepping(xVal, xPct, value) {
            if (value >= xVal.slice(-1)[0]) { return 100 }
            var j = getJ(value, xVal), va, vb, pa, pb; va = xVal[j - 1]; vb = xVal[j]; pa = xPct[j - 1]; pb = xPct[j]; return pa + (toPercentage([va, vb], value) / subRangeRatio(pa, pb))
        }
        function fromStepping(xVal, xPct, value) {
            if (value >= 100) { return xVal.slice(-1)[0] }
            var j = getJ(value, xPct), va, vb, pa, pb; va = xVal[j - 1]; vb = xVal[j]; pa = xPct[j - 1]; pb = xPct[j]; return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb))
        }
        function getStep(xPct, xSteps, snap, value) {
            if (value === 100) { return value }
            var j = getJ(value, xPct), a, b; if (snap) {
                a = xPct[j - 1]; b = xPct[j]; if ((value - a) > ((b - a) / 2)) { return b }
                return a
            }
            if (!xSteps[j - 1]) { return value }
            return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1])
        }
        function handleEntryPoint(index, value, that) {
            var percentage; if (typeof value === "number") { value = [value] }
            if (Object.prototype.toString.call(value) !== '[object Array]') { throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.") }
            if (index === 'min') { percentage = 0 } else if (index === 'max') { percentage = 100 } else { percentage = parseFloat(index) }
            if (!isNumeric(percentage) || !isNumeric(value[0])) { throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.") }
            that.xPct.push(percentage); that.xVal.push(value[0]); if (!percentage) { if (!isNaN(value[1])) { that.xSteps[0] = value[1] } } else { that.xSteps.push(isNaN(value[1]) ? !1 : value[1]) }
            that.xHighestCompleteStep.push(0)
        }
        function handleStepPoint(i, n, that) {
            if (!n) { return !0 }
            that.xSteps[i] = fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]); var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i]; var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1); var step = that.xVal[i] + (that.xNumSteps[i] * highestStep); that.xHighestCompleteStep[i] = step
        }
        function Spectrum(entry, snap, singleStep) {
            this.xPct = []; this.xVal = []; this.xSteps = [singleStep || !1]; this.xNumSteps = [!1]; this.xHighestCompleteStep = []; this.snap = snap; var index, ordered = []; for (index in entry) { if (entry.hasOwnProperty(index)) { ordered.push([entry[index], index]) } }
            if (ordered.length && typeof ordered[0][0] === "object") { ordered.sort(function (a, b) { return a[0][0] - b[0][0] }) } else { ordered.sort(function (a, b) { return a[0] - b[0] }) }
            for (index = 0; index < ordered.length; index++) { handleEntryPoint(ordered[index][1], ordered[index][0], this) }
            this.xNumSteps = this.xSteps.slice(0); for (index = 0; index < this.xNumSteps.length; index++) { handleStepPoint(index, this.xNumSteps[index], this) }
        }
        Spectrum.prototype.getMargin = function (value) {
            var step = this.xNumSteps[0]; if (step && ((value / step) % 1) !== 0) { throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' must be divisible by step.") }
            return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : !1
        }; Spectrum.prototype.toStepping = function (value) { value = toStepping(this.xVal, this.xPct, value); return value }; Spectrum.prototype.fromStepping = function (value) { return fromStepping(this.xVal, this.xPct, value) }; Spectrum.prototype.getStep = function (value) { value = getStep(this.xPct, this.xSteps, this.snap, value); return value }; Spectrum.prototype.getNearbySteps = function (value) { var j = getJ(value, this.xPct); return { stepBefore: { startValue: this.xVal[j - 2], step: this.xNumSteps[j - 2], highestStep: this.xHighestCompleteStep[j - 2] }, thisStep: { startValue: this.xVal[j - 1], step: this.xNumSteps[j - 1], highestStep: this.xHighestCompleteStep[j - 1] }, stepAfter: { startValue: this.xVal[j - 0], step: this.xNumSteps[j - 0], highestStep: this.xHighestCompleteStep[j - 0] } } }; Spectrum.prototype.countStepDecimals = function () { var stepDecimals = this.xNumSteps.map(countDecimals); return Math.max.apply(null, stepDecimals) }; Spectrum.prototype.convert = function (value) { return this.getStep(this.toStepping(value)) }; var defaultFormatter = { 'to': function (value) { return value !== undefined && value.toFixed(2) }, 'from': Number }; function validateFormat(entry) {
            if (isValidFormatter(entry)) { return !0 }
            throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.")
        }
        function testStep(parsed, entry) {
            if (!isNumeric(entry)) { throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.") }
            parsed.singleStep = entry
        }
        function testRange(parsed, entry) {
            if (typeof entry !== 'object' || Array.isArray(entry)) { throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.") }
            if (entry.min === undefined || entry.max === undefined) { throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.") }
            if (entry.min === entry.max) { throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.") }
            parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep)
        }
        function testStart(parsed, entry) {
            entry = asArray(entry); if (!Array.isArray(entry) || !entry.length) { throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.") }
            parsed.handles = entry.length; parsed.start = entry
        }
        function testSnap(parsed, entry) { parsed.snap = entry; if (typeof entry !== 'boolean') { throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.") } }
        function testAnimate(parsed, entry) { parsed.animate = entry; if (typeof entry !== 'boolean') { throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.") } }
        function testAnimationDuration(parsed, entry) { parsed.animationDuration = entry; if (typeof entry !== 'number') { throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.") } }
        function testConnect(parsed, entry) {
            var connect = [!1]; var i; if (entry === 'lower') { entry = [!0, !1] }
            else if (entry === 'upper') { entry = [!1, !0] }
            if (entry === !0 || entry === !1) {
                for (i = 1; i < parsed.handles; i++) { connect.push(entry) }
                connect.push(!1)
            }
            else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) { throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.") }
            else { connect = entry }
            parsed.connect = connect
        }
        function testOrientation(parsed, entry) { switch (entry) { case 'horizontal': parsed.ort = 0; break; case 'vertical': parsed.ort = 1; break; default: throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.") } }
        function testMargin(parsed, entry) {
            if (!isNumeric(entry)) { throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.") }
            if (entry === 0) { return }
            parsed.margin = parsed.spectrum.getMargin(entry); if (!parsed.margin) { throw new Error("noUiSlider (" + VERSION + "): 'margin' option is only supported on linear sliders.") }
        }
        function testLimit(parsed, entry) {
            if (!isNumeric(entry)) { throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.") }
            parsed.limit = parsed.spectrum.getMargin(entry); if (!parsed.limit || parsed.handles < 2) { throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.") }
        }
        function testPadding(parsed, entry) {
            if (!isNumeric(entry)) { throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric.") }
            if (entry === 0) { return }
            parsed.padding = parsed.spectrum.getMargin(entry); if (!parsed.padding) { throw new Error("noUiSlider (" + VERSION + "): 'padding' option is only supported on linear sliders.") }
            if (parsed.padding < 0) { throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number.") }
            if (parsed.padding >= 50) { throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be less than half the range.") }
        }
        function testDirection(parsed, entry) { switch (entry) { case 'ltr': parsed.dir = 0; break; case 'rtl': parsed.dir = 1; break; default: throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.") } }
        function testBehaviour(parsed, entry) {
            if (typeof entry !== 'string') { throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.") }
            var tap = entry.indexOf('tap') >= 0; var drag = entry.indexOf('drag') >= 0; var fixed = entry.indexOf('fixed') >= 0; var snap = entry.indexOf('snap') >= 0; var hover = entry.indexOf('hover') >= 0; if (fixed) {
                if (parsed.handles !== 2) { throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles") }
                testMargin(parsed, parsed.start[1] - parsed.start[0])
            }
            parsed.events = { tap: tap || snap, drag: drag, fixed: fixed, snap: snap, hover: hover }
        }
        function testTooltips(parsed, entry) {
            if (entry === !1) { return }
            else if (entry === !0) { parsed.tooltips = []; for (var i = 0; i < parsed.handles; i++) { parsed.tooltips.push(!0) } }
            else {
                parsed.tooltips = asArray(entry); if (parsed.tooltips.length !== parsed.handles) { throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.") }
                parsed.tooltips.forEach(function (formatter) { if (typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function')) { throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.") } })
            }
        }
        function testAriaFormat(parsed, entry) { parsed.ariaFormat = entry; validateFormat(entry) }
        function testFormat(parsed, entry) { parsed.format = entry; validateFormat(entry) }
        function testCssPrefix(parsed, entry) {
            if (entry !== undefined && typeof entry !== 'string' && entry !== !1) { throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.") }
            parsed.cssPrefix = entry
        }
        function testCssClasses(parsed, entry) {
            if (entry !== undefined && typeof entry !== 'object') { throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.") }
            if (typeof parsed.cssPrefix === 'string') {
                parsed.cssClasses = {}; for (var key in entry) {
                    if (!entry.hasOwnProperty(key)) { continue }
                    parsed.cssClasses[key] = parsed.cssPrefix + entry[key]
                }
            } else { parsed.cssClasses = entry }
        }
        function testUseRaf(parsed, entry) { if (entry === !0 || entry === !1) { parsed.useRequestAnimationFrame = entry } else { throw new Error("noUiSlider (" + VERSION + "): 'useRequestAnimationFrame' option should be true (default) or false.") } }
        function testOptions(options) {
            var parsed = { margin: 0, limit: 0, padding: 0, animate: !0, animationDuration: 300, ariaFormat: defaultFormatter, format: defaultFormatter }; var tests = { 'step': { r: !1, t: testStep }, 'start': { r: !0, t: testStart }, 'connect': { r: !0, t: testConnect }, 'direction': { r: !0, t: testDirection }, 'snap': { r: !1, t: testSnap }, 'animate': { r: !1, t: testAnimate }, 'animationDuration': { r: !1, t: testAnimationDuration }, 'range': { r: !0, t: testRange }, 'orientation': { r: !1, t: testOrientation }, 'margin': { r: !1, t: testMargin }, 'limit': { r: !1, t: testLimit }, 'padding': { r: !1, t: testPadding }, 'behaviour': { r: !0, t: testBehaviour }, 'ariaFormat': { r: !1, t: testAriaFormat }, 'format': { r: !1, t: testFormat }, 'tooltips': { r: !1, t: testTooltips }, 'cssPrefix': { r: !1, t: testCssPrefix }, 'cssClasses': { r: !1, t: testCssClasses }, 'useRequestAnimationFrame': { r: !1, t: testUseRaf } }; var defaults = { 'connect': !1, 'direction': 'ltr', 'behaviour': 'tap', 'orientation': 'horizontal', 'cssPrefix': 'noUi-', 'cssClasses': { target: 'target', base: 'base', origin: 'origin', handle: 'handle', handleLower: 'handle-lower', handleUpper: 'handle-upper', horizontal: 'horizontal', vertical: 'vertical', background: 'background', connect: 'connect', ltr: 'ltr', rtl: 'rtl', draggable: 'draggable', drag: 'state-drag', tap: 'state-tap', active: 'active', tooltip: 'tooltip', pips: 'pips', pipsHorizontal: 'pips-horizontal', pipsVertical: 'pips-vertical', marker: 'marker', markerHorizontal: 'marker-horizontal', markerVertical: 'marker-vertical', markerNormal: 'marker-normal', markerLarge: 'marker-large', markerSub: 'marker-sub', value: 'value', valueHorizontal: 'value-horizontal', valueVertical: 'value-vertical', valueNormal: 'value-normal', valueLarge: 'value-large', valueSub: 'value-sub' }, 'useRequestAnimationFrame': !0 }; if (options.format && !options.ariaFormat) { options.ariaFormat = options.format }
            Object.keys(tests).forEach(function (name) {
                if (options[name] === undefined && defaults[name] === undefined) {
                    if (tests[name].r) { throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.") }
                    return !0
                }
                tests[name].t(parsed, options[name] === undefined ? defaults[name] : options[name])
            }); parsed.pips = options.pips; var styles = [['left', 'top'], ['right', 'bottom']]; parsed.style = styles[parsed.dir][parsed.ort]; parsed.styleOposite = styles[parsed.dir ? 0 : 1][parsed.ort]; return parsed
        }
        function closure(target, options, originalOptions) {
            var actions = getActions(); var supportsTouchActionNone = getSupportsTouchActionNone(); var supportsPassive = supportsTouchActionNone && getSupportsPassive(); var scope_Target = target; var scope_Locations = []; var scope_Base; var scope_Handles; var scope_HandleNumbers = []; var scope_ActiveHandle = !1; var scope_Connects; var scope_Spectrum = options.spectrum; var scope_Values = []; var scope_Events = {}; var scope_Self; var scope_Pips; var scope_Listeners = null; var scope_Document = target.ownerDocument; var scope_DocumentElement = scope_Document.documentElement; var scope_Body = scope_Document.body; function addNodeTo(target, className) {
                var div = scope_Document.createElement('div'); if (className) { addClass(div, className) }
                target.appendChild(div); return div
            }
            function addOrigin(base, handleNumber) {
                var origin = addNodeTo(base, options.cssClasses.origin); var handle = addNodeTo(origin, options.cssClasses.handle); handle.setAttribute('data-handle', handleNumber); handle.setAttribute('tabindex', '0'); handle.setAttribute('role', 'slider'); handle.setAttribute('aria-orientation', options.ort ? 'vertical' : 'horizontal'); if (handleNumber === 0) { addClass(handle, options.cssClasses.handleLower) }
                else if (handleNumber === options.handles - 1) { addClass(handle, options.cssClasses.handleUpper) }
                return origin
            }
            function addConnect(base, add) {
                if (!add) { return !1 }
                return addNodeTo(base, options.cssClasses.connect)
            }
            function addElements(connectOptions, base) { scope_Handles = []; scope_Connects = []; scope_Connects.push(addConnect(base, connectOptions[0])); for (var i = 0; i < options.handles; i++) { scope_Handles.push(addOrigin(base, i)); scope_HandleNumbers[i] = i; scope_Connects.push(addConnect(base, connectOptions[i + 1])) } }
            function addSlider(target) {
                addClass(target, options.cssClasses.target); if (options.dir === 0) { addClass(target, options.cssClasses.ltr) } else { addClass(target, options.cssClasses.rtl) }
                if (options.ort === 0) { addClass(target, options.cssClasses.horizontal) } else { addClass(target, options.cssClasses.vertical) }
                scope_Base = addNodeTo(target, options.cssClasses.base)
            }
            function addTooltip(handle, handleNumber) {
                if (!options.tooltips[handleNumber]) { return !1 }
                return addNodeTo(handle.firstChild, options.cssClasses.tooltip)
            }
            function tooltips() {
                var tips = scope_Handles.map(addTooltip); bindEvent('update', function (values, handleNumber, unencoded) {
                    if (!tips[handleNumber]) { return }
                    var formattedValue = values[handleNumber]; if (options.tooltips[handleNumber] !== !0) { formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]) }
                    tips[handleNumber].innerHTML = formattedValue
                })
            }
            function aria() { bindEvent('update', function (values, handleNumber, unencoded, tap, positions) { scope_HandleNumbers.forEach(function (handleNumber) { var handle = scope_Handles[handleNumber]; var min = checkHandlePosition(scope_Locations, handleNumber, 0, !0, !0, !0); var max = checkHandlePosition(scope_Locations, handleNumber, 100, !0, !0, !0); var now = positions[handleNumber]; var text = options.ariaFormat.to(unencoded[handleNumber]); handle.children[0].setAttribute('aria-valuemin', min.toFixed(1)); handle.children[0].setAttribute('aria-valuemax', max.toFixed(1)); handle.children[0].setAttribute('aria-valuenow', now.toFixed(1)); handle.children[0].setAttribute('aria-valuetext', text) }) }) }
            function getGroup(mode, values, stepped) {
                if (mode === 'range' || mode === 'steps') { return scope_Spectrum.xVal }
                if (mode === 'count') {
                    if (!values) { throw new Error("noUiSlider (" + VERSION + "): 'values' required for mode 'count'.") }
                    var spread = (100 / (values - 1)); var v; var i = 0; values = []; while ((v = i++ * spread) <= 100) { values.push(v) }
                    mode = 'positions'
                }
                if (mode === 'positions') { return values.map(function (value) { return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value) }) }
                if (mode === 'values') {
                    if (stepped) { return values.map(function (value) { return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value))) }) }
                    return values
                }
            }
            function generateSpread(density, mode, group) {
                function safeIncrement(value, increment) { return (value + increment).toFixed(7) / 1 }
                var indexes = {}; var firstInRange = scope_Spectrum.xVal[0]; var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1]; var ignoreFirst = !1; var ignoreLast = !1; var prevPct = 0; group = unique(group.slice().sort(function (a, b) { return a - b })); if (group[0] !== firstInRange) { group.unshift(firstInRange); ignoreFirst = !0 }
                if (group[group.length - 1] !== lastInRange) { group.push(lastInRange); ignoreLast = !0 }
                group.forEach(function (current, index) {
                    var step; var i; var q; var low = current; var high = group[index + 1]; var newPct; var pctDifference; var pctPos; var type; var steps; var realSteps; var stepsize; if (mode === 'steps') { step = scope_Spectrum.xNumSteps[index] }
                    if (!step) { step = high - low }
                    if (low === !1 || high === undefined) { return }
                    step = Math.max(step, 0.0000001); for (i = low; i <= high; i = safeIncrement(i, step)) {
                        newPct = scope_Spectrum.toStepping(i); pctDifference = newPct - prevPct; steps = pctDifference / density; realSteps = Math.round(steps); stepsize = pctDifference / realSteps; for (q = 1; q <= realSteps; q += 1) { pctPos = prevPct + (q * stepsize); indexes[pctPos.toFixed(5)] = ['x', 0] }
                        type = (group.indexOf(i) > -1) ? 1 : (mode === 'steps' ? 2 : 0); if (!index && ignoreFirst) { type = 0 }
                        if (!(i === high && ignoreLast)) { indexes[newPct.toFixed(5)] = [i, type] }
                        prevPct = newPct
                    }
                }); return indexes
            }
            function addMarking(spread, filterFunc, formatter) {
                var element = scope_Document.createElement('div'); var valueSizeClasses = [options.cssClasses.valueNormal, options.cssClasses.valueLarge, options.cssClasses.valueSub]; var markerSizeClasses = [options.cssClasses.markerNormal, options.cssClasses.markerLarge, options.cssClasses.markerSub]; var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical]; var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical]; addClass(element, options.cssClasses.pips); addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical); function getClasses(type, source) { var a = source === options.cssClasses.value; var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses; var sizeClasses = a ? valueSizeClasses : markerSizeClasses; return source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type] }
                function addSpread(offset, values) { values[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1]; var node = addNodeTo(element, !1); node.className = getClasses(values[1], options.cssClasses.marker); node.style[options.style] = offset + '%'; if (values[1]) { node = addNodeTo(element, !1); node.className = getClasses(values[1], options.cssClasses.value); node.style[options.style] = offset + '%'; node.innerText = formatter.to(values[0]) } }
                Object.keys(spread).forEach(function (a) { addSpread(a, spread[a]) }); return element
            }
            function removePips() { if (scope_Pips) { removeElement(scope_Pips); scope_Pips = null } }
            function pips(grid) { removePips(); var mode = grid.mode; var density = grid.density || 1; var filter = grid.filter || !1; var values = grid.values || !1; var stepped = grid.stepped || !1; var group = getGroup(mode, values, stepped); var spread = generateSpread(density, mode, group); var format = grid.format || { to: Math.round }; scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format)); return scope_Pips }
            function baseSize() { var rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort]; return options.ort === 0 ? (rect.width || scope_Base[alt]) : (rect.height || scope_Base[alt]) }
            function attachEvent(events, element, callback, data) {
                var method = function (e) {
                    if (scope_Target.hasAttribute('disabled')) { return !1 }
                    if (hasClass(scope_Target, options.cssClasses.tap)) { return !1 }
                    e = fixEvent(e, data.pageOffset); if (!e) { return !1 }
                    if (events === actions.start && e.buttons !== undefined && e.buttons > 1) { return !1 }
                    if (data.hover && e.buttons) { return !1 }
                    if (!supportsPassive) { e.preventDefault() }
                    e.calcPoint = e.points[options.ort]; callback(e, data)
                }; var methods = []; events.split(' ').forEach(function (eventName) { element.addEventListener(eventName, method, supportsPassive ? { passive: !0 } : !1); methods.push([eventName, method]) }); return methods
            }
            function fixEvent(e, pageOffset) {
                var touch = e.type.indexOf('touch') === 0; var mouse = e.type.indexOf('mouse') === 0; var pointer = e.type.indexOf('pointer') === 0; var x; var y; if (e.type.indexOf('MSPointer') === 0) { pointer = !0 }
                if (touch) {
                    if (e.touches.length > 1) { return !1 }
                    x = e.changedTouches[0].pageX; y = e.changedTouches[0].pageY
                }
                pageOffset = pageOffset || getPageOffset(scope_Document); if (mouse || pointer) { x = e.clientX + pageOffset.x; y = e.clientY + pageOffset.y }
                e.pageOffset = pageOffset; e.points = [x, y]; e.cursor = mouse || pointer; return e
            }
            function calcPointToPercentage(calcPoint) { var location = calcPoint - offset(scope_Base, options.ort); var proposal = (location * 100) / baseSize(); return options.dir ? 100 - proposal : proposal }
            function getClosestHandle(proposal) {
                var closest = 100; var handleNumber = !1; scope_Handles.forEach(function (handle, index) {
                    if (handle.hasAttribute('disabled')) { return }
                    var pos = Math.abs(scope_Locations[index] - proposal); if (pos < closest) { handleNumber = index; closest = pos }
                }); return handleNumber
            }
            function moveHandles(upward, proposal, locations, handleNumbers) {
                var proposals = locations.slice(); var b = [!upward, upward]; var f = [upward, !upward]; handleNumbers = handleNumbers.slice(); if (upward) { handleNumbers.reverse() }
                if (handleNumbers.length > 1) { handleNumbers.forEach(function (handleNumber, o) { var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], !1); if (to === !1) { proposal = 0 } else { proposal = to - proposals[handleNumber]; proposals[handleNumber] = to } }) }
                else { b = f = [!0] }
                var state = !1; handleNumbers.forEach(function (handleNumber, o) { state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state }); if (state) { handleNumbers.forEach(function (handleNumber) { fireEvent('update', handleNumber); fireEvent('slide', handleNumber) }) }
            }
            function fireEvent(eventName, handleNumber, tap) { Object.keys(scope_Events).forEach(function (targetEvent) { var eventType = targetEvent.split('.')[0]; if (eventName === eventType) { scope_Events[targetEvent].forEach(function (callback) { callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || !1, scope_Locations.slice()) }) } }) }
            function documentLeave(event, data) { if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) { eventEnd(event, data) } }
            function eventMove(event, data) {
                if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) { return eventEnd(event, data) }
                var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint); var proposal = (movement * 100) / data.baseSize; moveHandles(movement > 0, proposal, data.locations, data.handleNumbers)
            }
            function eventEnd(event, data) {
                if (scope_ActiveHandle) { removeClass(scope_ActiveHandle, options.cssClasses.active); scope_ActiveHandle = !1 }
                if (event.cursor) { scope_Body.style.cursor = ''; scope_Body.removeEventListener('selectstart', preventDefault) }
                scope_Listeners.forEach(function (c) { scope_DocumentElement.removeEventListener(c[0], c[1]) }); removeClass(scope_Target, options.cssClasses.drag); setZindex(); data.handleNumbers.forEach(function (handleNumber) { fireEvent('change', handleNumber); fireEvent('set', handleNumber); fireEvent('end', handleNumber) })
            }
            function eventStart(event, data) {
                if (data.handleNumbers.length === 1) {
                    var handle = scope_Handles[data.handleNumbers[0]]; if (handle.hasAttribute('disabled')) { return !1 }
                    scope_ActiveHandle = handle.children[0]; addClass(scope_ActiveHandle, options.cssClasses.active)
                }
                event.stopPropagation(); var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, { startCalcPoint: event.calcPoint, baseSize: baseSize(), pageOffset: event.pageOffset, handleNumbers: data.handleNumbers, buttonsProperty: event.buttons, locations: scope_Locations.slice() }); var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, { handleNumbers: data.handleNumbers }); var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, { handleNumbers: data.handleNumbers }); scope_Listeners = moveEvent.concat(endEvent, outEvent); if (event.cursor) {
                    scope_Body.style.cursor = getComputedStyle(event.target).cursor; if (scope_Handles.length > 1) { addClass(scope_Target, options.cssClasses.drag) }
                    scope_Body.addEventListener('selectstart', preventDefault, !1)
                }
                data.handleNumbers.forEach(function (handleNumber) { fireEvent('start', handleNumber) })
            }
            function eventTap(event) {
                event.stopPropagation(); var proposal = calcPointToPercentage(event.calcPoint); var handleNumber = getClosestHandle(proposal); if (handleNumber === !1) { return !1 }
                if (!options.events.snap) { addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration) }
                setHandle(handleNumber, proposal, !0, !0); setZindex(); fireEvent('slide', handleNumber, !0); fireEvent('update', handleNumber, !0); fireEvent('change', handleNumber, !0); fireEvent('set', handleNumber, !0); if (options.events.snap) { eventStart(event, { handleNumbers: [handleNumber] }) }
            }
            function eventHover(event) { var proposal = calcPointToPercentage(event.calcPoint); var to = scope_Spectrum.getStep(proposal); var value = scope_Spectrum.fromStepping(to); Object.keys(scope_Events).forEach(function (targetEvent) { if ('hover' === targetEvent.split('.')[0]) { scope_Events[targetEvent].forEach(function (callback) { callback.call(scope_Self, value) }) } }) }
            function bindSliderEvents(behaviour) {
                if (!behaviour.fixed) { scope_Handles.forEach(function (handle, index) { attachEvent(actions.start, handle.children[0], eventStart, { handleNumbers: [index] }) }) }
                if (behaviour.tap) { attachEvent(actions.start, scope_Base, eventTap, {}) }
                if (behaviour.hover) { attachEvent(actions.move, scope_Base, eventHover, { hover: !0 }) }
                if (behaviour.drag) {
                    scope_Connects.forEach(function (connect, index) {
                        if (connect === !1 || index === 0 || index === scope_Connects.length - 1) { return }
                        var handleBefore = scope_Handles[index - 1]; var handleAfter = scope_Handles[index]; var eventHolders = [connect]; addClass(connect, options.cssClasses.draggable); if (behaviour.fixed) { eventHolders.push(handleBefore.children[0]); eventHolders.push(handleAfter.children[0]) }
                        eventHolders.forEach(function (eventHolder) { attachEvent(actions.start, eventHolder, eventStart, { handles: [handleBefore, handleAfter], handleNumbers: [index - 1, index] }) })
                    })
                }
            }
            function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
                if (scope_Handles.length > 1) {
                    if (lookBackward && handleNumber > 0) { to = Math.max(to, reference[handleNumber - 1] + options.margin) }
                    if (lookForward && handleNumber < scope_Handles.length - 1) { to = Math.min(to, reference[handleNumber + 1] - options.margin) }
                }
                if (scope_Handles.length > 1 && options.limit) {
                    if (lookBackward && handleNumber > 0) { to = Math.min(to, reference[handleNumber - 1] + options.limit) }
                    if (lookForward && handleNumber < scope_Handles.length - 1) { to = Math.max(to, reference[handleNumber + 1] - options.limit) }
                }
                if (options.padding) {
                    if (handleNumber === 0) { to = Math.max(to, options.padding) }
                    if (handleNumber === scope_Handles.length - 1) { to = Math.min(to, 100 - options.padding) }
                }
                to = scope_Spectrum.getStep(to); to = limit(to); if (to === reference[handleNumber] && !getValue) { return !1 }
                return to
            }
            function toPct(pct) { return pct + '%' }
            function updateHandlePosition(handleNumber, to) { scope_Locations[handleNumber] = to; scope_Values[handleNumber] = scope_Spectrum.fromStepping(to); var stateUpdate = function () { scope_Handles[handleNumber].style[options.style] = toPct(to); updateConnect(handleNumber); updateConnect(handleNumber + 1) }; if (window.requestAnimationFrame && options.useRequestAnimationFrame) { window.requestAnimationFrame(stateUpdate) } else { stateUpdate() } }
            function setZindex() { scope_HandleNumbers.forEach(function (handleNumber) { var dir = (scope_Locations[handleNumber] > 50 ? -1 : 1); var zIndex = 3 + (scope_Handles.length + (dir * handleNumber)); scope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex }) }
            function setHandle(handleNumber, to, lookBackward, lookForward) {
                to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, !1); if (to === !1) { return !1 }
                updateHandlePosition(handleNumber, to); return !0
            }
            function updateConnect(index) {
                if (!scope_Connects[index]) { return }
                var l = 0; var h = 100; if (index !== 0) { l = scope_Locations[index - 1] }
                if (index !== scope_Connects.length - 1) { h = scope_Locations[index] }
                scope_Connects[index].style[options.style] = toPct(l); scope_Connects[index].style[options.styleOposite] = toPct(100 - h)
            }
            function setValue(to, handleNumber) {
                if (to === null || to === !1) { return }
                if (typeof to === 'number') { to = String(to) }
                to = options.format.from(to); if (to !== !1 && !isNaN(to)) { setHandle(handleNumber, scope_Spectrum.toStepping(to), !1, !1) }
            }
            function valueSet(input, fireSetEvent) {
                var values = asArray(input); var isInit = scope_Locations[0] === undefined; fireSetEvent = (fireSetEvent === undefined ? !0 : !!fireSetEvent); values.forEach(setValue); if (options.animate && !isInit) { addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration) }
                scope_HandleNumbers.forEach(function (handleNumber) { setHandle(handleNumber, scope_Locations[handleNumber], !0, !1) }); setZindex(); scope_HandleNumbers.forEach(function (handleNumber) { fireEvent('update', handleNumber); if (values[handleNumber] !== null && fireSetEvent) { fireEvent('set', handleNumber) } })
            }
            function valueReset(fireSetEvent) { valueSet(options.start, fireSetEvent) }
            function valueGet() {
                var values = scope_Values.map(options.format.to); if (values.length === 1) { return values[0] }
                return values
            }
            function destroy() {
                for (var key in options.cssClasses) {
                    if (!options.cssClasses.hasOwnProperty(key)) { continue }
                    removeClass(scope_Target, options.cssClasses[key])
                }
                while (scope_Target.firstChild) { scope_Target.removeChild(scope_Target.firstChild) }
                delete scope_Target.noUiSlider
            }
            function getCurrentStep() {
                return scope_Locations.map(function (location, index) {
                    var nearbySteps = scope_Spectrum.getNearbySteps(location); var value = scope_Values[index]; var increment = nearbySteps.thisStep.step; var decrement = null; if (increment !== !1) { if (value + increment > nearbySteps.stepAfter.startValue) { increment = nearbySteps.stepAfter.startValue - value } }
                    if (value > nearbySteps.thisStep.startValue) { decrement = nearbySteps.thisStep.step }
                    else if (nearbySteps.stepBefore.step === !1) { decrement = !1 }
                    else { decrement = value - nearbySteps.stepBefore.highestStep }
                    if (location === 100) { increment = null }
                    else if (location === 0) { decrement = null }
                    var stepDecimals = scope_Spectrum.countStepDecimals(); if (increment !== null && increment !== !1) { increment = Number(increment.toFixed(stepDecimals)) }
                    if (decrement !== null && decrement !== !1) { decrement = Number(decrement.toFixed(stepDecimals)) }
                    return [decrement, increment]
                })
            }
            function bindEvent(namespacedEvent, callback) { scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || []; scope_Events[namespacedEvent].push(callback); if (namespacedEvent.split('.')[0] === 'update') { scope_Handles.forEach(function (a, index) { fireEvent('update', index) }) } }
            function removeEvent(namespacedEvent) { var event = namespacedEvent && namespacedEvent.split('.')[0]; var namespace = event && namespacedEvent.substring(event.length); Object.keys(scope_Events).forEach(function (bind) { var tEvent = bind.split('.')[0], tNamespace = bind.substring(tEvent.length); if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) { delete scope_Events[bind] } }) }
            function updateOptions(optionsToUpdate, fireSetEvent) {
                var v = valueGet(); var updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format']; updateAble.forEach(function (name) { if (optionsToUpdate[name] !== undefined) { originalOptions[name] = optionsToUpdate[name] } }); var newOptions = testOptions(originalOptions); updateAble.forEach(function (name) { if (optionsToUpdate[name] !== undefined) { options[name] = newOptions[name] } }); scope_Spectrum = newOptions.spectrum; options.margin = newOptions.margin; options.limit = newOptions.limit; options.padding = newOptions.padding; if (options.pips) { pips(options.pips) }
                scope_Locations = []; valueSet(optionsToUpdate.start || v, fireSetEvent)
            }
            if (scope_Target.noUiSlider) { throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.") }
            addSlider(scope_Target); addElements(options.connect, scope_Base); scope_Self = { destroy: destroy, steps: getCurrentStep, on: bindEvent, off: removeEvent, get: valueGet, set: valueSet, reset: valueReset, __moveHandles: function (a, b, c) { moveHandles(a, b, scope_Locations, c) }, options: originalOptions, updateOptions: updateOptions, target: scope_Target, removePips: removePips, pips: pips }; bindSliderEvents(options.events); valueSet(options.start); if (options.pips) { pips(options.pips) }
            if (options.tooltips) { tooltips() }
            aria(); return scope_Self
        }
        function initialize(target, originalOptions) {
            if (!target || !target.nodeName) { throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target) }
            var options = testOptions(originalOptions, target); var api = closure(target, options, originalOptions); target.noUiSlider = api; return api
        }
        return { version: VERSION, create: initialize }
    }))
}
catch (e) {

}